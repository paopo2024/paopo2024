//+================================================================================================+
//|                                                                                  2Sides_v5.0c5 |
//|                                                                               by Edition Qimer |
//|                                                                                     31.05.2013 |
//|                                                                                                |
//|                                                           2Sides_v5.0c6_765_mod_02_Joker62.mq4 |
//|                                                                         by mod Edition Joker62 |
//+================================================================================================+
//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
#property copyright ""
#property strict
//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
// Для работы советника необходимо выполнить ряд условий, в противном случае нормальная работа советника не гарантируется.
//
// 1) Разрешенный максимальный совокупный объем открытых ордеров в каждую из сторон должен быть не меньше 100лот (информацию об этом можно узнать на
//    сайте вашего ДЦ «типы счетов»)
// 2) Плечо (leverage), чем оно выше, тем меньший депозит будет необходим для торговли, и тем выше будет прибыль. Меньшее плечо убережет депо от вашей
//    жадности и неоправданного риска.
// 3) Необходимый депозит. Торговать можно с любым депозитом. Однако, при UseMM = true советник, в случае нехватки средств на счете, выведет
//    соответствующее сообщение и укажет, сколько необходимо иметь средств на счете при данных настройках советника.
//
//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
// Полностью переработан для нормальной работы под билда терминала 765. Здесь сделаны большая работа по улучшению работы советника в целом.
// С этой базисной основы, можно свободно модифицировать под разных типы задач.
//
// С большой благодарностью Gold-у за предоставления ряд функции в советнике.
//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
enum ENUM_YN
 {
  enum_n = 0, // Нет
  enum_y = 1  // Да
 };

enum ENUM_TF
 {
  eM0  = PERIOD_CURRENT, // текущий
  eM1  = PERIOD_M1,      // 1 минута
  eM5  = PERIOD_M5,      // 5 минут
  eM15 = PERIOD_M15,     // 15 минут
  eM30 = PERIOD_M30,     // 30 минут
  eH1  = PERIOD_H1,      // 1 час
  eH4  = PERIOD_H4,      // 4 часа
  eD1  = PERIOD_D1,      // 1 день
  eW1  = PERIOD_W1,      // 1 неделя
  eMN1 = PERIOD_MN1      // 1 месяц
 };
//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
extern string  separate_00____ = "~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~"; //~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
extern string  tx1             = "Общие настройки советника:"; //>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
extern ENUM_YN Info            = true;                        // Отображать инфо-панель?
/*
                               Переключатель, при значении true, отображается информация о балансе,
                               ордерах, коэффициенте увеличения лота и т.д.
*/
//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
/*extern*/ string  separate_01____ = "~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~"; //~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
/*extern*/ string  tx2             = "Настройки цветности:"; //>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
/*extern*/ color   MainInfoBack    = clrLightGray;
/*extern*/ color   MainInfo        = clrBlack;
/*extern*/ color   BuyInfoBack     = clrLightGray;
/*extern*/ color   BuyInfo         = clrBlack;
/*extern*/ color   SellInfoBack    = clrLightGray;
/*extern*/ color   SellInfo        = clrBlack;
/*extern*/ color   BuyColor        = clrBlue;
                               // Цвет линий для серий Buy
/*extern*/ color   SellColor       = clrRed;
                               // Цвет линий для серий Sell
/*extern*/ color   LOTColor        = clrPurple;
                               // Цвет линии ТП, при трале последних 2-х ордеров
/*extern*/ color   TralColor       = clrYellow;
                               // Цвет линии ТП при финальном трейлинге профита
//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
extern string  separate_02____ = "~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~"; //~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
extern ENUM_YN EnableBuy       = true;                        // Торговать только BUY?
/*
                               Переключатель. Если EnableBuy = true и EnableSell = false - советник будет торговать только в режиме по баям.
                               Селлы советник выставлять не будет.
*/
extern ENUM_YN EnableSell      = true;                        // Торговать только SELL?
/*
                               Переключатель. Если EnableSell = true и EnableBuy = false - советник будет торговать только в режиме по селлам.
                               Баи советник выставлять не будет.
                               ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
                               Если EnableBuy и EnableSell оба включены - работает стандартно, если оба false - торговать не будут, несмотря на то
                               что нажата кнопка "Торговать". Но если есть открытые ордера - советник доведет до конца закрытия ордеров.
*/
//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
extern string  separate_03____ = "~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~"; //~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
extern ENUM_YN UseVTP          = true;                        // Использовать режим VTP?
/*
                               Переключатель, при значении false советник использует режим, в котором советник модифицирует
                               ордера с выставлением фактического ТП серии, и серии закрываются брокером. При значении true
                               советник использует режим VTP с выставлением виртуального ТП и закрытием ордеров серии по
                               сигналу советника, также в этом режиме используется трейлинг прибыли.
                               ---------------------------------------------------------------------------------------------
                               В режиме VTP советник использует горизонтальные линии ТП (Virtual TakeProfit) для закрытия ордеров.
                               При очередном (ручном/автоматическом) открытии ордера серии советник рассчитывает новый уровень
                               цены для перемещения линии ТП.
                               При выходе цены за линию ТП (для «buy серии» снизу вверх, для «sell серии»  сверху вниз) на расстояние,
                               задаваемое в опциях как Tral_Start, линия ТП меняет свой цвет на, заданный в опциях советника, цвет Tral_Color.
                               Это свидетельствует о начале трала прибыли по серии. При продолжении движения цены в нужном направлении,
                               линия ТП будет следовать за ценой на расстоянии не более Tral_Size. При развороте цены, серия закроется
                               на уровне подтянутой линии ТП.
                               Важно отметить, что при удалении линии ТП, трал отменится и линия займет свое первоначальное положение.
                               Также необходимо отметить, что теперь линии ТП можно двигать, тем самым выбирая для себя необходимый
                               уровень закрытия серии, ожидаемый профит в единицах валюты отображается чуть ниже линии ТП. Т.е. можно
                               подобрать как необходимый уровень закрытия по определенной цене, так и необходимый профит.
                               Принудительное закрытие сери осуществляется точно так же.. Заводим линию ТП за цену, чтобы сработал трал.
                               Затем заводим линию за цену в обратном направлении, чтобы сработало закрытие серии.
                               В режиме UseVTP = false перемещение линий ТП влечет за собой изменение терминальных ТП. Режим защищен от
                               ошибки 130 (близкие стопы). Поэтому можно смело двигать линию. Важно только одно, что модификация ордеров
                               происходит сразу, поэтому не стоит долго перемещать эту линию, т.к. будет много модификаций ордеров и
                               обращений на сервер, что не приветствуется большинством ДЦ.
*/
extern int     Tral_Start_     = 5;                           // Старт трейлинга VTP
/*
                               Количество пунктов, на которое цена должна зайти за линию TP, чтобы начал работать трейлинг
                               (только для режима VTP)
*/
extern int     Tral_Size_      = 5;                           // Размер трейлинга VTP
                               // Размер трейлинг стопа (только для режима VTP)
//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
extern string  separate_04____ = "~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~"; //~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
extern ENUM_YN CloseBy         = false;                       // Использовать режим встречного закрытия ордеров?
/*
                               Переключатель, при значении true советник закрывает серии, используя встречное закрытие ордеров,
                               при значении false советник закрывает серии последовательно, начиная с большего ордера.
*/
extern ENUM_YN ManualTrade     = false;                       // Будем открывать первого ордера в ручную?
/*
                               Переключатель, при значении true переходит в режим ручной торговли, т.е. первый ордер открывает
                               сам трейдер, а советник, в случае неверного движения цены, сопровождает открытый ордер.
*/
//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
extern string  separate_05____ = "~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~"; //~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
extern ENUM_YN DynamicTP       = false;                       // Будем изменять досьтжения профита?
/*
                               Переключатель, в положении true переходит в режим, при котором общий ТейкПрофит серий будет
                               зависить от количество ордеров в сериях Sell и Buy (значения независимы)
*/
extern double  DynTP_Step_     = 1.0;                         // Шаг для динамического изменения достижения профита
//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
extern string  separate_06____ = "~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~"; //~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
extern ENUM_YN UseNewBar       = true;                        // Использовать режим открытия колен на новом баре?
/*
                               Переключатель, в положении true переходит в режим, при котором каждое новое колено серии будет
                               открываться на новом баре (работа зависит на каком ТФ стоит советник, т.е. на ТФ H1 новые колени
                               серии будут открываться не раньше чем через час)
*/
extern ENUM_TF UNB_TF          = 0;                           // Использовать UseNewBar по заданному тайм-фрейму
                               // Использовать UseNewBar по заданному тайм-фрейму. По умолчанию - текущий тайм-фрейм.
//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
extern string  separate_07____ = "~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~"; //~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
extern ENUM_YN ZTP             = false;                       // Использовать режим перевода ордеров в безубыток?
/*
                               Переключатель, в положении true переходит в режим, при котором советник после достижения
                               определенного количества ордеров (ZTP_order) в серии, переводит ТП в безубыток
*/
extern int     ZTP_order       = 6;                           // Количество ордеров до начала выполнения в безубыток
                               // Количество ордеров до начала выполнения в безубыток
//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
extern string  separate_08____ = "~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~"; //~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
extern ENUM_YN UseDaysBuffer   = true;                        // Будем сохранять все сделок на чарте-окна?
/*
                               Переключатель. В положение false - сохраняет все сделок, независимо от количества дней.
                               Если true - сохраняет только же дней, сколько указано в настройке.
*/
extern int     DaysBuffer      = 2;                           // Кол-во дней, в течении которых советник хранит на графике
                               // (также и как открытие/закрытие ордеров)
//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
extern string  separate_09____ = "~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~"; //~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
extern int     magicbuy        = 121;                         // Идентификатор меджика для ордера Buy
                               // Идентификатор меджика для открытия и закрытия (серии) ордера Buy
extern int     magicsell       = 122;                         // Идентификатор меджика для ордера Sell
                               // Идентификатор меджика для открытия и закрытия (серии) ордера Sell
extern int     magiclock       = 135797531;                   // Идентификатор для встречного ордера
                               // Идентификатор для встречного ордера, при включенном режиме CloseBy
extern string  magic_list      = "454 455 0";                 // Список идентификаторов ордеров
/*
                               Идентификаторы ордеров, которые советник будет считать своими. Заполняется с пробелом между
                               цифрами. Никаких лишних символов!
*/
//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
extern string  separate_10____ = "~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~"; //~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
extern string  tx3             = "Настройки системы LOT:"; //>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
extern ENUM_YN UseLOT          = false;                       // Использовать режим LOT?
/*
                               Переключатель, в положении true переходит в режим LOT. В этом режиме сов находит точку безубытка
                               последних 2-х ордеров серии и с помощью трала собирает прибыль по этим двум ордерам и выставляет
                               новое колено в серии, но уже чуть дальше, чем обычно. Таким образом, при малых откатах цены в
                               положительную сторону для серии собирается прибыль, которая накапливается в переменной, чтобы в
                               дальнейшем закрыть серию при достижении процента прибыли ProfitPercent (Советник не просто сравнивает
                               накопленную прибыль с установленным в опциях процентом, но еще и сверяется со Средствами/Equity)
*/
extern int     nOrder          = 5;                           // Порядковый номер ордера в серии, с которого включается LOT
                               // Порядковый номер ордера в серии, с которого включается LOT.
extern int     LO_TP_          = 5;                           // ТейкПрофит для LOT, количество пунктов от без убытка
/*
                               ТейкПрофит для LOT, количество пунктов от без убытка. Важно отметить, что на уровень этого ТП
                               влияет и TPstep. Формула такая: TP = LO_TP + Tpstep * trades, (где trades - количество текущих
                               ордеров серии)
*/
extern int     LO_Tral_Start_  = 3;                           // Количество пунктов для старта трала
                               // Количество пунктов, на которое цена должна зайти за линию LO_TP, чтобы начался трал
extern int     LO_Tral_Size_   = 5;                           // Количество пунктов, величина трала
                               // Количество пунктов, величина трала
extern int     ProfitPercent   = 15;                          // Процент достижения по ТейкПрофиту от размера баланса
/*
                               Процент достижения по ТейкПрофиту от размера баланса
                               ---------------------------------------------------------------------------------------------
                               Данная система имеет как плюсы, так и минусы. К плюсам относится существенная прибыль при резких
                               бросках цены, сдвиг ордеров, что немного уменьшает просадку. К минусам – затяжные просадки при
                               вялом тренде. Не рекомендую использовать LOT на больших депозитах с большим уровнем риска
                               (UseMoney > 30) и/или с низким числом ордеров в серии (MaxTrades < 8).
*/
//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
extern string  separate_11____ = "~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~"; //~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
extern string  tx4             = "Фильтр времени и Время работы советника"; //>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
extern ENUM_YN UseFilterTime   = false;                       // Запрет торговли в пятницу после и в понедельник до?
                               // Использовать запрет торговли в пятницу после и в понедельник до указанных времен
extern int     StartHourMonday = 7;                           // Время начала торговли в понедельник
extern int     EndHourFriday   = 19;                          // Время конца  торговли в пятницу
extern int     StartHour       = 0;                           // Время начала интервала работы советника
extern int     EndHour         = 24;                          // Время конца интервала работы советника
//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
extern string  separate_12____ = "~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~"; //~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
extern string  tx5             = "Настройки MoneyManagement:"; //>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
extern ENUM_YN UseMM           = false;                       // Советник рассчитывает объем первого ордера по ММ?
/*
                               Переключатель, при значении true объем первого ордера серии рассчитывается советником, а при
                               значении false объем первого ордера задает сам пользователь через переменную min_lot (выключать
                               UseMM советую лишь зная, что min_lot у вас меньше, чем рассчитанный в блоке ММ, иначе нормальная
                               работа советника не гарантируется!)
*/
extern ENUM_YN UseEquity       = true;                        // Советник рассчитывает объем первого ордера по средствам?
/*
                               Переключатель, при значении true в расчете объема 1-го ордера серии участвует не баланс, а средства.
                               Позволяет советнику корректно работать на счете, в котором есть локированая серия ордеров.
*/
extern double  min_lot         = 0.1;                         // Минимальный начальный размер лота для торговли
                               // Минимальный начальный размер лота для торговли. Минимальный допустимый размер лота уточняйтесь в своем ДЦ!
extern int     MaxTrades_Buy   = 6;                           // Максимум ордеров Buy в серии
/*
                               Здесь задается максимальное количество ордеров в сериях по Buy. Например, при значении MaxTrades = 4
                               советник откроет, если понадобится, лишь 3 дополнительных ордера (колен мартингейла).
*/
extern int     MaxTrades_Sell  = 6;                           // Максимум ордеров Sell в серии
/*
                               Здесь задается максимальное количество ордеров в сериях по Sell. Например, при значении MaxTrades = 4
                               советник откроет, если понадобится, лишь 3 дополнительных ордера (колен мартингейла).
*/
extern int     UseMoney        = 50;                          // Риск при использования режима ММ
/*
                               Процент использования баланса для расчета (можно понимать как «риск»)
                               ---------------------------------------------------------------------------------------------
                               Советник рассчитывает максимальный объем для первого ордера серии таким образом, чтобы смогло
                               открыться то количество ордеров, которое указано в переменной MaxTrades. Т.е. если указано
                               MaxTrades = 7 и Step = 30, то фактически советник рассчитывает на максимальное безоткатное движение в
                               7 * 30 + 30 = 240 пунктов (2400 для пятизнаков). Если UseMoney = 100, то при 241 - 250 пунктах безотката
                               произойдет слив депо. Чтобы застраховать депо, можно понизить значение UseMoney.
                               ---------------------------------------------------------------------------------------------
                               Важно отметить, что может сложиться такая ситуация, когда рассчитанный максимально возможный
                               объем для первой сделки будет меньше минимально возможного объема на данном счете, тогда советник
                               выдаст сообщение о нехватке средств со значением необходимого депозита для торговли, с учетом текущих
                               настроек советника. Поэтому адекватно выбирайте значения MaxTrades, UseMoney, mult и проверяйте сначала
                               на тестере.
*/
//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
extern string  separate_13____ = "~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~"; //~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
extern ENUM_YN DrawdownStop    = false;                       // Принудительно закрывать все открытые позиции?
/*
                               Переключатель, в положение DrowdownStop = true, советник принудительно закроет все открытые серии,
                               мэджик ордеров которых соответствует установленному в настройках magic.
*/
extern double  SL_Level        = 0.0;                         // Уровень просадки в %
                               // Уровень просадки в процентах. Если SL_Level = 0 - принудительное закрытие просевшие ордера закрывать не будет!
extern ENUM_YN CloseBuy        = false;                       // Закрывать просевшие ордера BUY?
/*
                               Переключатель. В положение true - советник будет принудительно закрывать просевшие ордера по Buy,
                               согласно по заданному уровню SL_Level.
*/
extern ENUM_YN CloseSell       = false;                       // Закрывать просевшие ордера SELL?
/*
                               Переключатель. В положение true - советник будет принудительно закрывать просевшие ордера по Sell,
                               согласно по заданному уровню SL_Level.
*/
//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
extern string  separate_14____ = "~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~"; //~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
extern string  tx6             = "Основные настройки:"; //>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
extern ENUM_YN CurrencyProfit  = false;                       // Считать профит в процентах, а не в пунктах?
/*
                               Переключатель, в положении true переходит в режим, при котором ТейкПрофит будет рассчитываться
                               не в пунктах, а в процентах от баланса, который был на момент открытия первого ордера серии
*/
extern double  Profit          = 1.0;                         // Процент прибыли профита
                               // Процент прибыли при режиме CurrencyProfit = true
//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
extern string  separate_15____ = "~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~"; //~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
extern int     TP1_Buy_        = 8;                           // ТейкПрофит для каждой серии для BUY
                               // ТейкПрофит для каждой серии, в пунктах от безубытка (цены, при которой серия закроется в 0)
extern int     TP_Buy_         = 8;                           // ТейкПрофит для 1-го ордера серии для BUY
                               // ТейкПрофит для первого ордера серии, в пунктах от безубытка
extern int     TPstep_Buy_     = 2;                           // Кол-во пунктов, на которое будет увелич-ся ТП в серии для BUY
/*
                               Количество пунктов, на которое будет увеличиваться ТП серии при открытии нового колена. Переменная
                               введена для того, чтобы профит соответствовал риску, больше риск (просадка) –> больше профит
*/
extern int     step_Buy        = 30;                          // Шаг в пунктах для открытия колен мартингейла по BUY
                               // ПипСтеп, шаг в пунктах для открытия колен мартингейла
extern double  Step_coef_Buy   = 1;                           // Множитель шага для BUY
/*
                               Множитель пипстепа, для очередного колена серии рассчитывается новый пипстеп.
                               Step = Step_coef * i, (где i – i-й ордер серии)
*/
extern double  mult_Buy        = 2;                           // Множитель лота для новых колен по BUY
/*
                               Множитель лота для новых колен (то же, что и LotExponent), выражает во сколько раз очередной
                               ордер серии будет превосходить предыдущий по объему
*/
extern string  separate_16____ = "~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~"; //~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
extern int     TP1_Sell_       = 8;                           // ТейкПрофит для каждой серии для SELL
                               // ТейкПрофит для каждой серии, в пунктах от безубытка (цены, при которой серия закроется в 0)
extern int     TP_Sell_        = 8;                           // ТейкПрофит для 1-го ордера серии для SELL
                               // ТейкПрофит для первого ордера серии, в пунктах от безубытка
extern int     TPstep_Sell_    = 2;                           // Кол-во пунктов, на которое будет увелич-ся ТП в серии для SELL
/*
                               Количество пунктов, на которое будет увеличиваться ТП серии при открытии нового колена. Переменная
                               введена для того, чтобы профит соответствовал риску, больше риск (просадка) –> больше профит
*/
extern int     step_Sell       = 30;                          // Шаг в пунктах для открытия колен мартингейла по SELL
                              // ПипСтеп, шаг в пунктах для открытия колен мартингейла
extern double  Step_coef_Sell  = 1;                           // Множитель шага для SELL
/*
                               Множитель пипстепа, для очередного колена серии рассчитывается новый пипстеп.
                               Step = Step_coef * i, (где i – i-й ордер серии)
*/
extern double  mult_Sell       = 2;                           // Множитель лота для новых колен по SELL
/*
                               Множитель лота для новых колен (то же, что и LotExponent), выражает во сколько раз очередной
                               ордер серии будет превосходить предыдущий по объему
*/
//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
extern string  separate_17____ = "~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~"; //~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
extern ENUM_YN UseAutoSlip     = false;                       // Задать двойной спред?
/*
                               Переключатель. Если в положение true - выставляет удвоенное размер на плавающий (фиксированный) спрейд.
                               Если false - выставляет советником в указанном настройке пользователя-трейдера.
*/
extern int     slippage        = 3;                           // Проскальзывание цены при реквотах
                               // Максимальное отклонение цены для открытия ордера при реквотах (проскальживание)
//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
extern string  separate_18____ =  "~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~"; //~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
extern string  tx7             = "Настройки индикатора Stochastic_Buy:"; //>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
extern ENUM_TF StochTime_Buy   = 0;                          // Таймфрейм
/*
                               Таймфрейм на котором работает индикатор Stochastic. Значение выражено в минутах, соответственно
                               0 - текущий ТМ, M1 – 1, M5 – 5, M30 – 30, H1 – 60, H4 – 240, D1 – 1440 и т.д.
*/
extern int     per_K_Buy       = 10;                          // Период %К
extern int     per_D_Buy       = 3;                           // Период %D
extern int     slow_Buy        = 3;                           // Замедление
extern ENUM_MA_METHOD S_Mode_Buy = 0;                         // Метод МА
extern int     S_Price_Buy     = 0;                           // Расчет по ценам: 0 - Low/High, 1 - Close/Close
extern int     zoneBUY_Buy     = 15;                          // Уровень перепроданности для Buy
extern int     zoneSELL_Buy    = 85;                          // Уровень перекупленности для Buy
//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
extern string  separate_19____ =  "~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~"; //~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
extern string  tx8             = "Настройки индикатора Stochastic_Sell:"; //>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
extern ENUM_TF StochTime_Sell  = 0;                          // Таймфрейм
/*
                               Таймфрейм на котором работает индикатор Stochastic. Значение выражено в минутах, соответственно
                               0 - текущий ТМ, M1 – 1, M5 – 5, M30 – 30, H1 – 60, H4 – 240, D1 – 1440 и т.д.
*/
extern int     per_K_Sell      = 10;                          // Период %К
extern int     per_D_Sell      = 3;                           // Период %D
extern int     slow_Sell       = 3;                           // Замедление
extern ENUM_MA_METHOD S_Mode_Sell = 0;                        // Метод МА
extern int     S_Price_Sell    = 0;                           // Расчет по ценам: 0 - Low/High, 1 - Close/Close
extern int     zoneBUY_Sell    = 15;                          // Уровень перепроданности для Sell
extern int     zoneSELL_Sell   = 85;                          // Уровень перекупленности для Sell
//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
extern string  separate_20____ = "~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~"; //~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
extern string  tx13            = "Установки перекрытия"; //>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
extern ENUM_YN UseOverlap      = false;                       // Использовать перекрытие?
extern int     LeadingOrder    = 4;                           // C какого колена работает перекрытие?
extern double  ProfitPersent   = 30.0;                        // Процент перекрытия (10...50)
extern double  SecondProfitPersent = 50.0;                    // Процент перекрытия когда подключается предпоследний ордер
extern ENUM_YN Debug           = false;                       // Отображать отладку перекрытия?
//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
extern string  separate_21____ =  "~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~"; //~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
extern string  InfoIPrice      = "Индикация текущей курсы валют"; //>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
extern ENUM_YN   Info_IPrice   = false;                       // Отображать текущий курс валюты?
extern string  separate_22____ = "~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~"; //~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
       double minLot,     maxLot,
              LOTStep,    smbuy,
              smsell,     vmtpb,
              vmtps,      vLO_mtpb,
              vLO_mtps;
       //------------------------------
       double DynTP_Step, Cprofit,
              Lprofit1,   Lprofit;
       
       int    i,            j,
              CU,           totb,
              tots,         r,
              cnt,          dig,
              hb = 0,       hs = 0,
              TicketB[],    TicketS[],
              magic[10],    cmagic;
       //------------------------------
       int    Tral_Start,   Tral_Size,
              Step_Buy,     Step_Sell,
              TPstep_Buy,   TPstep_Sell,
              TP_Buy,       TP_Sell,
              TP1_Buy,      TP1_Sell,
              LO_Tral_Size, LO_Tral_Start,
              LO_TP,        Slippage,
              Cpos,         Lpos1,
              Lpos;
       
       color  col,       vctpb,
              vctps,     vcLO_mtpb,
              vcLO_mtps;
       
       string txt1,      txt2,
              txt3,      txt4,
              txtVTP,    txtLOT,
              tm;
       
       bool   TradeOff,  NotFast;
       
       datetime NewBar_B, NewBar_S;
       
       //--------------------
       double LastOrdersBuyLots,   LastOrdersSellLots,
              LastOrdersBuyProfit, LastOrdersSellProfit,
              ProfitBuyN,          ProfitSellN;
//===================================================================================================================================================
int OnInit()
 {
  DeleteObject();
  
  if (GlobalVariableCheck("2ss_TPBuy") ||
      GlobalVariableCheck("2ss_TPSell"))
   GlobalVariablesDeleteAll(NULL);
  
  TradeOff = false;
  
  LOTStep = MarketInfo(Symbol(), MODE_LOTSTEP);
  minLot  = MarketInfo(Symbol(), MODE_MINLOT);
  maxLot  = MarketInfo(Symbol(), MODE_MAXLOT);
  
  int spread = (int)MathFloor(MarketInfo(Symbol(), MODE_SPREAD));
  
  // количество знаков после запятой
  dig = 2;
  
  if ((!IsTesting() || IsVisualMode()) && !IsOptimization())
   NotFast = true;
  
  // коэффициент для разных типов счетов 4/2 и 5/3
  if (Digits == 4 ||
      Digits == 2)
   CU = 1;
  else
   CU = 10;
  
  // увеличиваем все необходимые параметры на этот коэффиент
  Tral_Start    = Tral_Start_    * CU;
  Tral_Size     = Tral_Size_     * CU;
  DynTP_Step    = DynTP_Step_    * CU;
  LO_TP         = LO_TP_         * CU;
  LO_Tral_Start = LO_Tral_Start_ * CU;
  LO_Tral_Size  = LO_Tral_Size_  * CU;
  TP1_Buy       = TP1_Buy_       * CU;
  TP1_Sell      = TP1_Sell_      * CU;
  TP_Buy        = TP_Buy_        * CU;
  TP_Sell       = TP1_Sell_      * CU;
  TPstep_Buy    = TPstep_Buy_    * CU;
  TPstep_Sell   = TPstep_Sell_   * CU;
  Step_Buy      = step_Buy       * CU;
  Step_Sell     = step_Sell      * CU;
  
  if (UseAutoSlip)
   Slippage = (int)(2 * spread * CU);
  else
   Slippage = slippage * CU;
  
  // производится проверка, удовлетворяет ли баланс настройкам, заданным в советнике.
  double lotx_Buy  = MM(mult_Buy, UseMoney, MaxTrades_Buy,  Step_Buy);
  double lotx_Sell = MM(mult_Buy, UseMoney, MaxTrades_Sell, Step_Sell);
  
  if (UseMM && lotx_Buy < minLot)
   TradeStop();
  
  if (UseMM && lotx_Sell < minLot)
   TradeStop();
  
  if (!UseMM && min_lot < minLot)
   {
    tm       = "min_lot меньше возможного на счете";                      // Защита от неверно введенного парамтера min_lot
    TradeOff = true;
   }
  
  //------ Чтение магиков из списка -----
  cmagic = 0;
  
  string st;
  
  int k = StringLen(magic_list);
  
  for (int a = 0; a < k; a++)
   {
    if (StringSubstr(magic_list, a, 1) != " ")
     {
      st = st + StringSubstr(magic_list, a, 1);
      
      if (a < k - 1)
       continue;
     }
    
    if (st != "")
     {
      magic[cmagic] = StrToInteger(st);
      cmagic++;
      st = " ";
     }
   }
  
  //----- Проверка глобальных переменных ----
  double gtpb = GlobalVariableGet("2ss_TPBuy"),
         gtps = GlobalVariableGet("2ss_TPSell");
  
  if (gtpb > 0)
   DrawLine("SellTP", gtpb, SellColor, 2);
  
  if (gtps > 0)
   DrawLine("BuyTP", gtps, BuyColor, 2);
  
  //--------------------------------
  return(INIT_SUCCEEDED);
 }
//===================================================================================================================================================
void OnDeinit(const int reason)
 {
  Comment("");
  
  double gtpb = ObjectGet("BuyTP",  OBJPROP_PRICE1),
         gtps = ObjectGet("SellTP", OBJPROP_PRICE1);
  
  if (gtpb > 0)
   GlobalVariableSet("2ss_TPBuy", gtpb);
  
  if (gtps > 0)
   GlobalVariableSet("2ss_TPSell", gtps);
  
  ObjectDelete("SellTP");
  ObjectDelete("BuyTP");
  
  ObjectDelete("SellZeroLevel");
  ObjectDelete("BuyZeroLevel");
  
  ObjectDelete("SellLOT");
  ObjectDelete("BuyLOT");
  
  ObjectDelete("Lable1");
  ObjectDelete("Lable2");
  ObjectDelete("Lable3");
  
  ObjectDelete("y_MainInfoBack1");
  ObjectDelete("y_MainInfoBack2");
  ObjectDelete("y_MainInfoBack3");
  
  ObjectDelete("z_MainInfo_1");
  ObjectDelete("z_MainInfo_2");
  ObjectDelete("z_MainInfo_3");
  ObjectDelete("z_MainInfo_4");
  ObjectDelete("z_MainInfo_5");
  ObjectDelete("z_MainInfo_6");
  ObjectDelete("z_MainInfo_7");
  
  ObjectDelete("z_BuyInfo_1");
  ObjectDelete("z_BuyInfo_2");
  ObjectDelete("z_BuyInfo_3");
  ObjectDelete("z_BuyInfo_4");
  ObjectDelete("z_BuyInfo_5");
  ObjectDelete("z_BuyInfo_6");
  ObjectDelete("z_BuyInfo_7");
  
  ObjectDelete("z_SellInfo_1");
  ObjectDelete("z_SellInfo_2");
  ObjectDelete("z_SellInfo_3");
  ObjectDelete("z_SellInfo_4");
  ObjectDelete("z_SellInfo_5");
  ObjectDelete("z_SellInfo_6");
  ObjectDelete("z_SellInfo_7");
  
  ObjectDelete("z_ErrorB");
  ObjectDelete("z_ErrorM");
  
  ObjectDelete("BuyTP_Back");
  ObjectDelete("BuyTP_Text");
  
  ObjectDelete("SellTP_Back");
  ObjectDelete("SellTP_Text");
  
  //----------------------------
  return;
 }
//===================================================================================================================================================
void OnTick()
 {
  double TV     = MarketInfo(Symbol(), MODE_TICKVALUE);
  double spread = MathFloor(MarketInfo(Symbol(), MODE_SPREAD));
  
  //------------------------- Запрет торговли -------------------------------------------
  if (TradeOff)
   {
    Text("z_ErrorB", "gggggggggggggggggggggggggg",  24, "Webdings",    100, 200, clrRed);
    Text("z_ErrorM", "Торговля остановлена! " + tm, 15, "Arial Black", 110, 201, clrYellow);
    
    return; //(0);
   }
  
  //========================= Сбор данных о торговле ==================================================================
  totb = 0;
  tots = 0;
  
  ArrayResize(TicketB, OrdersTotal());
  ArrayResize(TicketS, OrdersTotal());
  
  //------------------------- Заполнение массивов тикетов -------------------------------
  Filling_Array_Tickets();
  
  //------------------------- Сортировка массивов тикетов -------------------------------
  //------------------------- Для серии BUY ---------------------------------------------
  Sorts_Array_Tickets_Buy();
  
  //------------------------- Для серии SELL --------------------------------------------
  Sorts_Array_Tickets_Sell();
  
  //------------------------- Подсчет профита, объемов и т.д. открытых ордеров ----------
  double profitbuy    = 0.0, profitsell    = 0.0,
         openpricebuy = 0.0, openpricesell = 0.0,
         lastlotbuy   = 0.0, lastlotsell   = 0.0,
         TPB          = 0.0, TPS           = 0.0;
  
  smbuy  = 0;
  smsell = 0;
  
  for (i = totb - 1; i >= 0; i--)
   if (OrderSelect(TicketB[i], SELECT_BY_TICKET))
    {
     smbuy       += OrderLots();
     profitbuy   += OrderProfit() + OrderCommission() + OrderSwap();
     openpricebuy = OrderOpenPrice();
     lastlotbuy   = OrderLots();
     TPB          = OrderTakeProfit();
    }
  
  for (i = tots - 1; i >= 0; i--)
   if (OrderSelect(TicketS[i], SELECT_BY_TICKET))
    {
     smsell       += OrderLots();
     profitsell   += OrderProfit() + OrderCommission() + OrderSwap();
     openpricesell = OrderOpenPrice();
     lastlotsell   = OrderLots();
     TPS           = OrderTakeProfit();
    }
  
  //---------- Расчет ТП в зависимости от кол-ва ордеров и включенных режимов -----------
  double TPbuy, TPsell;
  
  if (totb == 1)
   TPbuy = TP1_Buy;
  else
   TPbuy = TP_Buy;
  
  if (tots == 1)
   TPsell = TP1_Sell;
  else
   TPsell = TP_Sell;
  
  if (DynamicTP)
   {
    TPbuy  += (totb - 1) * DynTP_Step;
    TPsell += (tots - 1) * DynTP_Step;
   }
  
  if (ZTP)
   {
    if (totb >= ZTP_order)
     TPbuy = 0;
    
    if (tots >= ZTP_order)
     TPsell = 0;
   }
  
  //===================================================================================================================
  double ProfitBuy  = 0.0, ProfitSell  = 0.0,
         BalanceBuy = 0.0, BalanceSell = 0.0;
  
  BalanceBuy  = AccountBalance();
  BalanceSell = AccountBalance();
  
  //========================= LOT - Модуль обработки 2-х последних ордеров ============================================
  if (UseLOT)
   LOT(ProfitBuy,  ProfitSell,
       BalanceBuy, BalanceSell);
  
  //========================= модуль Расчета ТейкПрофита для обоих серий ==============================================
  double tpb     = 0.0, tps     = 0.0,
         ztpb    = 0.0, ztps    = 0.0,
         LOtpb   = 0.0, LOtps   = 0.0,
         mtpb    = 0.0, mtps    = 0.0,
         LO_mtpb = 0.0, LO_mtps = 0.0;
  
  color  ctpb     = 0, ctps     = 0,
         cLO_mtps = 0, cLO_mtpb = 0;
  
  //------------------------- Для серии BUY ---------------------------------------------
  CalculateTP_Buy(TV, profitbuy, BalanceBuy, ztpb, tpb, LOtpb, TPbuy);
  
  //------------------------- Для серии SELL --------------------------------------------
  CalculateTP_Sell(TV, profitsell, BalanceSell, ztps, tps, LOtps, TPsell);
  
  //------------------------- Определяем цену и цвет линий ТП и LOT ---------------------
  if (NotFast && ObjectFind("BuyTP") == 0)
   {
    mtpb = (double)ObjectGet("BuyTP",        OBJPROP_PRICE1);
    ctpb = (color) ObjectGet("BuyTP",        OBJPROP_COLOR);
    ztpb = (double)ObjectGet("BuyZeroLevel", OBJPROP_PRICE1);
    
    double ptpb  = (mtpb - Bid)  / Point * smbuy * TV + profitbuy;
    double pptpb = (mtpb - ztpb) / Point;
    
    TextT("BuyTP_Back", "gggggggggg", mtpb, "Webdings", ctpb);
    TextT("BuyTP_Text", DoubleToString(ptpb, 2) + " / " + DoubleToString(pptpb, 0), mtpb, "Arial Black", clrBlack);
   }
  else
   {
    mtpb = vmtpb;
    ctpb = vctpb;
   }
  
  if (NotFast && ObjectFind("SellTP") == 0)
   {
    mtps = (double)ObjectGet("SellTP",        OBJPROP_PRICE1);
    ctps = (color) ObjectGet("SellTP",        OBJPROP_COLOR);
    ztps = (double)ObjectGet("SellZeroLevel", OBJPROP_PRICE1);
    
    double ptps  = (Ask  - mtps) / Point * smsell * TV + profitsell;
    double pptps = (ztps - mtps) / Point;
    
    TextT("SellTP_Back", "gggggggggg", mtps, "Webdings", ctps);
    TextT("SellTP_Text", DoubleToString(ptps, 2) + " / " + DoubleToString(pptps, 0), mtps, "Arial Black", clrBlack);
   }
  else
   {
    mtps = vmtps;
    ctps = vctps;
   }
  
  if (NotFast && ObjectFind("BuyLOT") == 0)
   {
    LO_mtpb  = (double)ObjectGet("BuyLOT", OBJPROP_PRICE1);
    cLO_mtpb = (color) ObjectGet("BuyLOT", OBJPROP_COLOR);
   }
  else
   {
    LO_mtpb  = vLO_mtpb;
    cLO_mtpb = vcLO_mtpb;
   }
  
  if (NotFast && ObjectFind("SellLOT") == 0)
   {
    LO_mtps  = (double)ObjectGet("SellLOT", OBJPROP_PRICE1);
    cLO_mtps = (color) ObjectGet("SellLOT", OBJPROP_COLOR);
   }
  else
   {
    LO_mtps  = vLO_mtps;
    cLO_mtps = vcLO_mtps;
   }
  
  //========================= Трал VTP ================================================================================
  if (UseVTP)
   Trail_VTP((int)ctpb, (int)ctps,
                  mtpb,      mtps);
  
  //========================= Модификация ордеров при выключенном VTP =================================================
  else
   Trail_VTP_OFF(mtpb, mtps, TPB, TPS);
  
  //========================= Трал LOT ================================================================================
  if (UseLOT)
   Trail_LOT(mtpb,          mtps,
             LO_mtpb,       LO_mtps,
             (int)cLO_mtpb, (int)cLO_mtps);
  
  //===================================================================================================================
  double dd = 0.0, ee = 0.0;
  
  if (profitbuy + profitsell < 0)
   dd = MathAbs(profitbuy + profitsell) / (AccountEquity() - (profitbuy + profitsell)) * 100;
  
  if (DrawdownStop)
   {
    if (SL_Level == 0)
     return;
    else
     {
      if (dd >= SL_Level && (profitbuy + profitsell) < 0)
       {
        if (totb > 0)
         closeBUYorders();
        
        if (tots > 0)
         closeSELLorders();
       }
      
      ee = NormalizeDouble((1 - (AccountEquity() / AccountBalance()) * 100), 2);
      
      if (CloseBuy)
       if (profitbuy < 0 && ee >= SL_Level)
        closeBUYorders();
      
      if (CloseSell)
       if (profitsell < 0 && ee >= SL_Level)
        closeSELLorders();
     }
   }
  
  //===================================================================================================================
  if (UseLOT && (ProfitBuyN + profitbuy) >= BalanceBuy * ProfitPercent / 100)
   closeBUYorders();
  
  if (UseLOT && (ProfitSellN + profitsell) >= BalanceSell * ProfitPercent / 100)
   closeSELLorders();
  
  //========================= Визуализация информации =================================================================
  if (NotFast)
   {
    //----------------------- Удаление устаревших объектов ------------------------------
    for (int ii = ObjectsTotal() - 1; ii >= 0; ii--)
     {
      string ObName = ObjectName(ii);
      
      if (UseDaysBuffer && !IsOptimization())
       {
        if (ObjectGet(ObName, OBJPROP_TIME1) > 0 &&
            ObjectGet(ObName, OBJPROP_TIME1) < (Time[0] - DaysBuffer * 86400))
         if (ObName != "SellTP"        &&
             ObName != "SellLOT"       &&
             ObName != "SellZeroLevel" &&
             ObName != "SellTP_Back"   &&
             ObName != "SellTP_Text"   &&
             ObName != "BuyTP"         &&
             ObName != "BuyZeroLevel"  &&
             ObName != "BuyTP_Back"    &&
             ObName != "BuyTP_Text"    &&
             ObName != "BuyLOT")
          ObjectDelete(ObName);
       }
      else
       {
        if (!IsOptimization())
         if (ObName == "SellTP"        &&
             ObName == "SellLOT"       &&
             ObName == "SellZeroLevel" &&
             ObName == "SellTP_Back"   &&
             ObName == "SellTP_Text"   &&
             ObName == "BuyTP"         &&
             ObName == "BuyZeroLevel"  &&
             ObName == "BuyTP_Back"    &&
             ObName == "BuyTP_Text"    &&
             ObName == "BuyLOT")
          ObjectDelete(ObName);
       }
     }
   }
  
  //----------------------- Отображение инфо-панели Баланс/Средства/Просадка ----------------------
  if (Info && !IsOptimization())
   Info_Panel(mtpb,      mtps,       LO_mtpb,   LO_mtps,
              profitbuy, profitsell, ProfitBuy, ProfitSell);
  
  //------------------------- Отображение текущей курса валют ---------------------------
  if (Info_IPrice && !IsOptimization())
   Indication("IPrice", 1, 10, 120, StringConcatenate("", DoubleToStr(MarketInfo(Symbol(), MODE_BID), Digits)), 40, "Times New Roman", clrDodgerBlue);
  
  //===================================================================================================================
  double lotsbuy = 0.0, lotssell = 0.0;
  
  //========================= Открытие 1-го ордера по индикатору ======================================================
  if (time() && totb == 0 && EnableBuy)
   if ((UseNewBar && NewBar_B != iTime(Symbol(), StochTime_Buy, 0)) || !UseNewBar)
    if (!ManualTrade && Stochastic_Buy("buy"))
     {
      if (UseMM)
       {
        lotsbuy = MM(mult_Buy, UseMoney, MaxTrades_Buy, Step_Buy);
        
        if (lotsbuy < minLot)
         {
          TradeStop();
          
          return;
         }
       }
      else
       lotsbuy = min_lot;
      
      if (AccountFreeMarginCheck(Symbol(), OP_BUY, lotsbuy) > 0)
       ОткрытьОрдер(OP_BUY, lotsbuy, "1-й ордер Buy, " + (string)IntegerToString(magicbuy), magicbuy);
      
      if (UseNewBar)
       NewBar_B = iTime(Symbol(), UNB_TF, 0);
     }
   
   //------------------------------------------------------------------------------------
   if (time() && tots == 0 && EnableSell)
    if ((UseNewBar && NewBar_S != iTime(Symbol(), StochTime_Sell, 0)) || !UseNewBar)
     if (!ManualTrade && Stochastic_Sell("sell"))
      {
       if (UseMM)
        {
         lotssell = MM(mult_Sell, UseMoney, MaxTrades_Sell, Step_Sell);
         
         if (lotssell < minLot)
          {
           TradeStop();
           
           return;
          }
        }
       else
        lotssell = min_lot;
       
       if (AccountFreeMarginCheck(Symbol(), OP_SELL, lotssell) > 0)
        ОткрытьОрдер(OP_SELL, lotssell, "1-й ордер Sell, " + (string)IntegerToString(magicsell), magicsell);
       
       if (UseNewBar)
        NewBar_S = iTime(Symbol(), UNB_TF, 0);
      }
   
   //==================================================================================================================
  double lotsbuy2 = 0.0, lotssell2 = 0.0;
  
  //========================= Усреднение позиций BUY ==================================================================
  if (totb > 0 && EnableBuy)
   if ((UseNewBar && NewBar_B != iTime(Symbol(), UNB_TF, 0)) || !UseNewBar)
    if (Ask <= openpricebuy - MathFloor(Step_Buy * MathPow(Step_coef_Buy, totb - 1)) * Point && totb < MaxTrades_Buy)
     {
      lotsbuy2 = lastlotbuy * mult_Buy;
      
      if (UseNewBar)
       NewBar_B = iTime(Symbol(), UNB_TF, 0);
      
      if (AccountFreeMarginCheck(Symbol(), OP_BUY, lotsbuy2) > 0)
       ОткрытьОрдер(OP_BUY, lotsbuy2, (string)IntegerToString(totb + 1) + "-й ордер Buy, " +
                                      (string)IntegerToString(magicbuy), magicbuy);
     }
   
  //========================= Усреднение позиций SELL =================================================================
  if (tots > 0 && EnableSell)
   if ((UseNewBar && NewBar_S != iTime(Symbol(), UNB_TF, 0)) || !UseNewBar)
    if (Bid >= openpricesell + MathFloor(Step_Sell * MathPow(Step_coef_Sell, tots - 1)) * Point && tots < MaxTrades_Sell)
     {
      lotssell2 = lastlotsell * mult_Sell;
      
      if (UseNewBar)
       NewBar_S = iTime(Symbol(), UNB_TF, 0);
      
      if (AccountFreeMarginCheck(Symbol(), OP_SELL,lotssell2) > 0)
       ОткрытьОрдер(OP_SELL, lotssell2, (string)IntegerToString(tots + 1) + "-й ордер Sell, " +
                                        (string)IntegerToString(magicsell), magicsell);
     }
  
  //===================================================================================================================
   if (UseOverlap)
   if (LeadingOrder >= 2)
    CheckOverlapping(totb, tots);
  //===================================================================================================================
  return;
 }
//===================================================================================================================================================
//===================================================================== Ф У Н К Ц И И ===============================================================
//===================================================================================================================================================
bool time()
 {
  if (UseFilterTime)                                        // Если включен режим проверки по времени, то проверяем....
   {
    if (DayOfWeek() == 0  ||                                // Воскресенье
        DayOfWeek() == 6)                                   // Суббота
     return(false);                                         // Не торговать в выходные
    
    if ((Hour() <  StartHourMonday && DayOfWeek() == 1)  || // Не торговать в понедельник раньше времени
        (Hour() >= EndHourFriday   && DayOfWeek() == 5))    // Не торговать в пятницу после указанного времени
     return(false);                                         // отдыхаем и ждем своего времени. :)
   }
  
  if (StartHour < EndHour)
   {
    if (Hour() >= StartHour &&
        Hour() <  EndHour)
     return(true);
    else
     return(false);
   }
  
  if (StartHour > EndHour)
   {
    if (Hour() >= EndHour &&
        Hour() <  StartHour)
     return(false);
    else
     return(true);
   }
  
  //-------------------------
  return(false);
 }
//===================================================================================================================================================
bool Stochastic_Buy(string SMode)
 {
  double sM0 = iStochastic(Symbol(), StochTime_Buy, per_K_Buy, per_D_Buy, slow_Buy, S_Mode_Buy, S_Price_Buy, MODE_MAIN, 0);
  double sM1 = iStochastic(Symbol(), StochTime_Buy, per_K_Buy, per_D_Buy, slow_Buy, S_Mode_Buy, S_Price_Buy, MODE_MAIN, 1);
  
  double sS0 = iStochastic(Symbol(), StochTime_Buy, per_K_Buy, per_D_Buy, slow_Buy, S_Mode_Buy, S_Price_Buy, MODE_SIGNAL, 0);
  double sS1 = iStochastic(Symbol(), StochTime_Buy, per_K_Buy, per_D_Buy, slow_Buy, S_Mode_Buy, S_Price_Buy, MODE_SIGNAL, 1);
  
  if (SMode == "buy" && sS0 <  zoneBUY_Buy &&
                        sM0 <  zoneBUY_Buy &&
                        sM1 <  sS1         &&
                        sM0 >= sS0)
   return(true);
  
  if (SMode == "sell" && sS0 >  zoneSELL_Buy &&
                         sM0 >  zoneSELL_Buy &&
                         sM1 >  sS1          &&
                         sM0 <= sS0)
   return(true);
  
  //-------------------------
  return(false);
 }
//===================================================================================================================================================
bool Stochastic_Sell(string SMode)
 {
  double sM0 = iStochastic(Symbol(), StochTime_Sell, per_K_Sell, per_D_Sell, slow_Sell, S_Mode_Sell, S_Price_Sell, MODE_MAIN, 0);
  double sM1 = iStochastic(Symbol(), StochTime_Sell, per_K_Sell, per_D_Sell, slow_Sell, S_Mode_Sell, S_Price_Sell, MODE_MAIN, 1);
  
  double sS0 = iStochastic(Symbol(), StochTime_Sell, per_K_Sell, per_D_Sell, slow_Sell, S_Mode_Sell, S_Price_Sell, MODE_SIGNAL, 0);
  double sS1 = iStochastic(Symbol(), StochTime_Sell, per_K_Sell, per_D_Sell, slow_Sell, S_Mode_Sell, S_Price_Sell, MODE_SIGNAL, 1);
  
  if (SMode == "buy" && sS0 <  zoneBUY_Sell &&
                        sM0 <  zoneBUY_Sell &&
                        sM1 <  sS1          &&
                        sM0 >= sS0)
   return(true);
  
  if (SMode == "sell" && sS0 >  zoneSELL_Sell &&
                         sM0 >  zoneSELL_Sell &&
                         sM1 >  sS1           &&
                         sM0 <= sS0)
   return(true);
  
  //-------------------------
  return(false);
 }
//===================================================================================================================================================
void closeBUYorders()
 {
  int ii, tt, jj;
  
  bool q;
  
  if (CloseBy && !IsTesting())
   {
    while (ОткрытьОрдер(OP_SELL, smbuy, "", magiclock) <= 0)
     Sleep(1000);
    
    for (ii = 0; ii < totb; ii++)
     {
      tt = 0;
      
      for (jj = OrdersTotal() - 1; jj >= 0; jj--)
       {
        if (OrderSelect(jj, SELECT_BY_POS, MODE_TRADES))
         {
          if (OrderSymbol()      == Symbol() &&
              OrderType()        == OP_SELL  &&
              OrderMagicNumber() == magiclock)
           {
            tt = OrderTicket();
            
            break;
           }
         }
       }
      
      q = false;
      
      while (!q)
       {
        RefreshRates();
        
        q = OrderCloseBy(TicketB[ii], tt, BuyColor);
        
        Sleep(1000);
       }
     }
   }
  else
   {
    for (ii = 0; ii < totb; ii++)
     {
      if (OrderSelect(TicketB[ii], SELECT_BY_TICKET))
       {
        q = false;
        
        while (!q)
         {
          RefreshRates();
          
          q = OrderClose(TicketB[ii], OrderLots(), NormalizeDouble(Bid, Digits), Slippage, BuyColor);
          
          Sleep(1000);
         }
       }
     }
   }
  
  //-------------------------
  return;
 }
//===================================================================================================================================================
void closeSELLorders()
 {
  int ii, tt, jj;
  
  bool q;
  
  if (CloseBy && !IsTesting())
   {
    while (ОткрытьОрдер(OP_BUY, smsell, "", magiclock) <= 0)
     Sleep(1000);
    
    for (ii = 0; ii < tots; ii++)
     {
      tt = 0;
      
      for (jj = OrdersTotal() - 1; jj >= 0; jj--)
       {
        if (OrderSelect(jj, SELECT_BY_POS, MODE_TRADES))
         {
          if (OrderSymbol()      == Symbol() &&
              OrderType()        == OP_BUY   &&
              OrderMagicNumber() == magiclock)
           {
            tt = OrderTicket();
            
            break;
           }
         }
       }
      
      q = false;
      
      while (!q)
       {
        RefreshRates();
        
        q = OrderCloseBy(TicketS[ii], tt, SellColor);
        
        Sleep(1000);
       }
     }
   }
  else
   {
    for (ii = 0; ii < tots; ii++)
     {
      if (OrderSelect(TicketS[ii], SELECT_BY_TICKET))
       {
        q = false;
        
        while (!q)
         {
          RefreshRates();
          
          q = OrderClose(TicketS[ii], OrderLots(), NormalizeDouble(Ask, Digits), Slippage, SellColor);
          
          Sleep(1000);
         }
       }
     }
   }
  
  //-------------------------
  return;
 }
//===================================================================================================================================================
void CloseLastOrdersBuy()
 {
  int ii;
  
  bool q;
  
  for (ii = 0; ii < 2; ii++)
   {
    if (OrderSelect(TicketB[ii], SELECT_BY_TICKET))
     {
      q = false;
      
      while (!q)
       {
        RefreshRates();
        
        q = OrderClose(TicketB[ii], OrderLots(), NormalizeDouble(Bid, Digits), Slippage, BuyColor);
        
        Sleep(1000);
       }
     }
   }
  
  //-------------------------
  return;
 }
//===================================================================================================================================================
void CloseLastOrdersSell()
 {
  int ii;
  
  bool q;
  
  for (ii = 0; ii < 2; ii++)
   {
    if (OrderSelect(TicketS[ii], SELECT_BY_TICKET))
     {
      q = false;
      
      while(!q)
       {
        RefreshRates();
        
        q = OrderClose(TicketS[ii], OrderLots(), NormalizeDouble(Ask, Digits), Slippage, SellColor);
        
        Sleep(1000);
       }
     }
   }
  
  //-------------------------
  return;
 }
//===================================================================================================================================================
double MM(double mult1, int UM, int MaxTrades1, int step1)
 {
  double trade_vol = 1;
  double sum_vol   = 1;
  
  double MaxDrawdown;
  
  maxLot = MarketInfo(Symbol(), MODE_MAXLOT);
  
  double margin = MarketInfo(Symbol(), MODE_MARGINREQUIRED);
  double TV1    = MarketInfo(Symbol(), MODE_TICKVALUE);
  
  int cnt2, cnt3;
  
  double marginsum, points;
  
  for (cnt2 = MaxTrades1; cnt2 >= 1; cnt2--)
   {
    points = 0;
    
    for (cnt3 = MaxTrades1 - cnt2; cnt3 < MaxTrades1; cnt3++)
     {
      if (EnableBuy)
       points += NormalizeDouble(step1 * MathPow(Step_coef_Buy, cnt3), 0);
      
      if (EnableSell)
       points += NormalizeDouble(step1 * MathPow(Step_coef_Sell, cnt3), 0);
     }
    
    MaxDrawdown += trade_vol * points * TV1;                              // расчет максимальной просадки при объеме 1-го ордера в 1.00 лот
    sum_vol     += trade_vol;
    trade_vol   *= mult1;
   }
  
  marginsum = margin * sum_vol;
  
  double depo;
  
  if (UseEquity)
   depo = AccountEquity();
  else
   depo = AccountBalance();
  
  double lot = NormalizeDouble(((depo + AccountCredit()) * UM / 100) / (MaxDrawdown + marginsum), dig);  // расчет максимального объема для 1-го ордера серии
  
  if (lot * sum_vol > maxLot)                                                                            // проверка на максимально возможный объем 1-го ордера серии
   lot = NormalizeDouble(maxLot / sum_vol, dig);
  
  return(lot);
 }
//===================================================================================================================================================
void TradeStop()
 {
  if (totb + tots > 0)
   return;
  
  int cnt2, cnt3;
  
  double trade_vol = 1, points;
  double sum_vol   = 1;
  
  double MaxDrawdown = 0.0, marginsum = 0.0;
  
  minLot = MarketInfo(Symbol(), MODE_MINLOT);
  
  double margin = MarketInfo(Symbol(), MODE_MARGINREQUIRED);
  double TV1    = MarketInfo(Symbol(), MODE_TICKVALUE);
  
  if (EnableBuy)
   for (cnt2 = MaxTrades_Buy; cnt2 >= 1; cnt2--)
    {
     points = 0;
     
     for (cnt3 = MaxTrades_Buy - cnt2; cnt3 < MaxTrades_Buy; cnt3++)
      points += NormalizeDouble(step_Buy * MathPow(Step_coef_Buy, cnt3), 0);
     
     MaxDrawdown += trade_vol * points * TV1;
     sum_vol     += trade_vol;
     trade_vol   *= mult_Buy;
    }
  
  if (EnableSell)
   for (cnt2 = MaxTrades_Sell; cnt2 >= 1; cnt2--)
   {
    points = 0;
    
    for (cnt3 = MaxTrades_Sell - cnt2; cnt3 < MaxTrades_Sell; cnt3++)
     points += NormalizeDouble(step_Buy * MathPow(Step_coef_Sell, cnt3), 0);
    
     MaxDrawdown += trade_vol * points * TV1;
     sum_vol     += trade_vol;
     trade_vol   *= mult_Sell;
   }
  
  marginsum = margin * sum_vol;
  
  double deposit = minLot * (MaxDrawdown + marginsum) / UseMoney * 100;
  
  tm = "Недостаточно средств, необходимо " + (string)DoubleToString(deposit) + " ед.";
  
  TradeOff = true;
 }
//===================================================================================================================================================
void Text(string name, string text, int size, string font, int xd, int yd, color colT)
 {
  int w = WindowFind("2SS");
  
  if (w == -1)
   w = 0;
  
  if (ObjectFind("y_MainInfoBack1") != w)
   ObjectDelete("y_MainInfoBack1");
  
  if (ObjectFind("y_MainInfoBack2") != w)
   ObjectDelete("y_MainInfoBack2");
  
  if (ObjectFind("y_MainInfoBack3") != w)
   ObjectDelete("y_MainInfoBack3");
  
  if (ObjectFind(name) == 0 && w != 0)
   ObjectDelete(name);
  
  ObjectCreate (name, OBJ_LABEL, w, 0, 0);
  ObjectSetText(name, text, size, font);
  ObjectSet    (name, OBJPROP_XDISTANCE, xd);
  ObjectSet    (name, OBJPROP_YDISTANCE, yd);
  ObjectSet    (name, OBJPROP_COLOR, colT);
  ObjectSet    (name, OBJPROP_BACK, false);
  
  //-------------------------
  return;
 }
//===================================================================================================================================================
void TextT(string name, string txt, double y, string sh, color C)
 {
  double dc = MathFloor(WindowFirstVisibleBar() / 2);
  
  int cntr = (int)dc;
  
  bool q;
  
  if (ObjectFind(name) != 0)
   ObjectCreate(name, OBJ_TEXT, 0, Time[cntr], y);
  else
   q = ObjectMove(name, 0, Time[cntr], y);
  
  if (!q)
   Print(DoubleToStr(cntr,3), " ", Time[cntr]);
  
  ObjectSetText(name, txt, 10, sh, C);
  
  //-------------------------
  return;
 }
//===================================================================================================================================================
void DrawLine(string name,double price, color _col, int w)
 {
  double dc = MathFloor(WindowFirstVisibleBar() / 2);
  
  int cntr = (int)dc;
  
  bool q;
  
  if (ObjectFind(name) != 0)
   ObjectCreate(name, OBJ_HLINE, 0, Time[cntr], price);
  else
   q = ObjectMove(name, 0, Time[cntr], price);
  
  if (!q)
   Print(DoubleToStr(cntr, 3), " ", Time[cntr]);
  
  ObjectSet(name, OBJPROP_COLOR, _col);
  ObjectSet(name, OBJPROP_WIDTH, w);
  
  //-------------------------
  return;
 }
//===================================================================================================================================================
int ОткрытьОрдер(int тип, double объем, string комент, int мэджик)
 {
  if (!IsTradeAllowed())
   return(0);
  
  double цена = 0.0;
  
  color цвет = clrNONE;
  
  string ордер;
  
  RefreshRates();
  
  switch (тип)
   {
    case OP_BUY  : цена  = Ask;
                   цвет  = BuyColor;
                   ордер = "Buy";
                   break;
    case OP_SELL : цена  = Bid;
                   цвет  = SellColor;
                   ордер = "Sell";
   }
  
  int t = OrderSend(Symbol(), тип, NormalizeDouble(объем, 2),
                                   NormalizeDouble(цена, Digits), Slippage, 0, 0, комент, мэджик, 0, цвет);
  
  Sleep(1000);
  
  //-------------------------
  return(t);
 }
//===================================================================================================================================================
bool MagicCheck()
 {
  for (int ii = 0; ii < cmagic; ii++)
   {
    if (OrderMagicNumber() == magic[ii])
     return(true);
   }
  
  //-------------------------
  return(false);
 }
//===================================================================================================================================================
void Info_Panel(double mtpb,      double mtps,       double LO_mtpb,   double LO_mtps,
                double profitbuy, double profitsell, double ProfitBuy, double ProfitSell)
 {
  double dd = 0.0;
  double TV = MarketInfo(Symbol(), MODE_TICKVALUE);
  
  int pips    = 0;
  int spread_ = (int)MathFloor(MarketInfo(Symbol(), MODE_SPREAD));
  // изменение цвета при уменьшении "СРЕДСТВА" относительно "БАЛАНС"
  double Balans   = AccountBalance(),
         Sredstva = AccountEquity();
  
  if (Sredstva >= Balans / 6 * 5)
   col = clrDodgerBlue;
  
  if (Sredstva >= Balans / 6 * 4 &&
      Sredstva <  Balans / 6 * 5)
   col = clrDeepSkyBlue;
  
  if (Sredstva >= Balans / 6 * 3 &&
      Sredstva <  Balans / 6 * 4)
   col = clrGold;
  
  if (Sredstva >= Balans / 6 * 2 &&
      Sredstva <  Balans / 6 * 3)
   col = clrOrangeRed;
  
  if (Sredstva >= Balans / 6 &&
      Sredstva <  Balans /6 * 2)
   col = clrCrimson;
  
  if (Sredstva < Balans / 5)
   col = clrRed;
  
  //-------------------------
  if (profitbuy + profitsell < 0)
   dd = MathAbs(profitbuy + profitsell) / (AccountEquity() - (profitbuy + profitsell)) * 100;
  
  //-------------------------
  ObjectCreate ("Lable1", OBJ_LABEL, 0, 0, 1.0);
  ObjectSet    ("Lable1", OBJPROP_CORNER, 3);
  ObjectSet    ("Lable1", OBJPROP_XDISTANCE, 10);
  ObjectSet    ("Lable1", OBJPROP_YDISTANCE, 51);
  txt1 = (DoubleToString(AccountBalance(), 2));
  ObjectSetText("Lable1", "БАЛАНС     " + txt1 + "", 12, "Times New Roman", clrDodgerBlue);
  
  //-------------------------
  ObjectCreate ("Lable2", OBJ_LABEL, 0, 0, 1.0);
  ObjectSet    ("Lable2", OBJPROP_CORNER, 3);
  ObjectSet    ("Lable2", OBJPROP_XDISTANCE, 10);
  ObjectSet    ("Lable2", OBJPROP_YDISTANCE, 31);
  txt2 = (DoubleToString(AccountEquity(), 2));
  ObjectSetText("Lable2", "СРЕДСТВА     " + txt2 + "", 12, "Times New Roman", col);
  
  //-------------------------
  ObjectCreate ("Lable3", OBJ_LABEL, 0, 0, 1.0);
  ObjectSet    ("Lable3", OBJPROP_CORNER, 3);
  ObjectSet    ("Lable3", OBJPROP_XDISTANCE, 10);
  ObjectSet    ("Lable3", OBJPROP_YDISTANCE, 11);
  txt4 = DoubleToString(dd, 3) + "%";
  ObjectSetText("Lable3", "ПРОСАДКА     " + txt4 + "", 12, "Times New Roman", clrGreen);
  
  //--------------------------------------------------------- Отображение инфопанелей -----------------------------------------------------------
  string spips;
  
  double stopout_balance = AccountMargin() * AccountStopoutLevel() / 100;
  
  if (profitbuy + profitsell < 0)
   dd = MathAbs(profitbuy + profitsell) / (AccountEquity() - (profitbuy + profitsell)) * 100;
  
  if (MathAbs(smbuy - smsell) > 0)
   pips = (int)NormalizeDouble((AccountEquity() - stopout_balance) / MathAbs(smbuy - smsell) / TV, 0);
  
  if (smbuy > smsell)
   spips = "До слива " + (string)IntegerToString(pips) + " пунктов вниз";
  
  if (smbuy < smsell)
   spips = "До слива " + (string)IntegerToString(pips) + " пунктов вверх";
  
  if (smbuy == smsell)
   {
    if (smbuy == 0)
     spips = "Нет ордеров";
    else
     spips = "Лок";
   }
  
  if (UseVTP)
   txtVTP = "Режим VTP вкл. ";
  else
   txtVTP = "Режим VTP выкл.";
  
  if (UseLOT)
   txtLOT = "Режим LOT вкл. ";
  else
   txtLOT = "Режим LOT выкл.";
  
  int x1, y1, x2, y2, x3, y3;
  
  if (ObjectFind("y_MainInfoBack1") == -1)
   Text("y_MainInfoBack1", "gggg", 58, "Webdings", 0, 0, MainInfoBack);
  
  if (ObjectFind("y_MainInfoBack2") == -1)
   Text("y_MainInfoBack2", "gggg", 58, "Webdings", 320, 0, BuyInfoBack);
  
  if (ObjectFind("y_MainInfoBack3") == -1)
   Text("y_MainInfoBack3", "gggg", 58, "Webdings", 640, 0, SellInfoBack);
  
  //-------------------------
  x1 = (int)ObjectGet("y_MainInfoBack1", OBJPROP_XDISTANCE);
  y1 = (int)ObjectGet("y_MainInfoBack1", OBJPROP_YDISTANCE);
  x2 = (int)ObjectGet("y_MainInfoBack2", OBJPROP_XDISTANCE);
  y2 = (int)ObjectGet("y_MainInfoBack2", OBJPROP_YDISTANCE);
  x3 = (int)ObjectGet("y_MainInfoBack3", OBJPROP_XDISTANCE);
  y3 = (int)ObjectGet("y_MainInfoBack3", OBJPROP_YDISTANCE);
  
  //-------------------------
  Text("z_MainInfo_1", txtVTP, 9, "Arial Black", x1 + 20,  y1 + 6, MainInfo);
  Text("z_MainInfo_2", txtLOT, 9, "Arial Black", x1 + 165, y1 + 6, MainInfo);
  Text("z_MainInfo_3", "мин.лот:  "  + DoubleToString(minLot, 2),            9, "Arial Black", x1 +  20, y1 + 21, MainInfo);
  Text("z_MainInfo_4", "макс.лот:  " + DoubleToString(maxLot, 0),            9, "Arial Black", x1 + 165, y1 + 21, MainInfo);
  Text("z_MainInfo_5", "спред:  "    + DoubleToString(spread_, 0) + "п",     9, "Arial Black", x1 +  20, y1 + 36, MainInfo);
  Text("z_MainInfo_6", "плечо:  1:"  + DoubleToString(AccountLeverage(), 0), 9, "Arial Black", x1 + 165, y1 + 36, MainInfo);
  Text("z_MainInfo_7", spips, 9, "Arial Black", x1 + 20, y1 + 51, MainInfo);
  
  //-------------------------
  Text("z_BuyInfo_1", "BUY", 9, "Arial Black", x2 + 130, y2 + 6, BuyInfo);
  Text("z_BuyInfo_2", "Ордеров:  " + DoubleToString(totb, 0),         9, "Arial Black", x2 +  20, y2 + 21, BuyInfo);
  Text("z_BuyInfo_3", "Объем:  "   + DoubleToString(smbuy, 2),        9, "Arial Black", x2 + 165, y2 + 21, BuyInfo);
  Text("z_BuyInfo_4", "Ур.TP:  "   + DoubleToString(mtpb, Digits),    9, "Arial Black", x2 +  20, y2 + 36, BuyInfo);
  Text("z_BuyInfo_5", "Ур.LOTP:  " + DoubleToString(LO_mtpb, Digits), 9, "Arial Black", x2 + 165, y2 + 36, BuyInfo);
  Text("z_BuyInfo_6", "Профит:  "  + DoubleToString(profitbuy, 2),    9, "Arial Black", x2 +  20, y2 + 51, BuyInfo);
  
  if (UseLOT)
   Text("z_BuyInfo_7", "Нак.профит:  " + DoubleToString(ProfitBuy, 2) + "%", 9, "Arial Black", x2 + 165, y2 + 51, BuyInfo);
  
  //-------------------------
  Text("z_SellInfo_1", "SELL", 9, "Arial Black", x3 + 125, y3 + 6, SellInfo);
  Text("z_SellInfo_2", "Ордеров:  " + DoubleToString(tots, 0),         9, "Arial Black", x3 +  20, y3 + 21, SellInfo);
  Text("z_SellInfo_3", "Объем:  "   + DoubleToString(smsell, 2),       9, "Arial Black", x3 + 165, y3 + 21, SellInfo);
  Text("z_SellInfo_4", "Ур.TP:  "   + DoubleToString(mtps, Digits),    9, "Arial Black", x3 +  20, y3 + 36, SellInfo);
  Text("z_SellInfo_5", "Ур.LOTP:  " + DoubleToString(LO_mtps, Digits), 9, "Arial Black", x3 + 165, y3 + 36, SellInfo);
  Text("z_SellInfo_6", "Профит:  "  + DoubleToString(profitsell, 2),   9, "Arial Black", x3 +  20, y3 + 51, SellInfo);
  
  if (UseLOT)
   Text("z_SellInfo_7", "Нак.профит:  " + DoubleToString(ProfitSell, 2) + "%", 9, "Arial Black", x3 + 165, y3 + 51, SellInfo);
  
  //-------------------------
  return;
 }
//===================================================================================================================================================
void LOT(double ProfitBuy,  double ProfitSell,
         double BalanceBuy, double BalanceSell)
 {
  datetime TimeB = Time[0], TimeS = Time[0];
  
  if (OrderSelect(TicketB[totb - 1], SELECT_BY_TICKET))
   TimeB = OrderOpenTime();
  
  if (OrderSelect(TicketS[tots - 1], SELECT_BY_TICKET))
   TimeS = OrderOpenTime();
  
  if (totb >= nOrder)
   {
    if (OrderSelect(TicketB[0], SELECT_BY_TICKET))
     {
      LastOrdersBuyLots   = OrderLots();
      LastOrdersBuyProfit = OrderProfit() + OrderCommission() + OrderSwap();
     }
    
    if (OrderSelect(TicketB[1], SELECT_BY_TICKET))
     {
      LastOrdersBuyLots   += OrderLots();
      LastOrdersBuyProfit += OrderProfit() + OrderCommission() + OrderSwap();
     }
   }
  
  if (tots >= nOrder)
   {
    if (OrderSelect(TicketS[0], SELECT_BY_TICKET))
     {
      LastOrdersSellLots   = OrderLots();
      LastOrdersSellProfit = OrderProfit() + OrderCommission() + OrderSwap();
     }
    
    if (OrderSelect(TicketS[1], SELECT_BY_TICKET))
     {
      LastOrdersSellLots   += OrderLots();
      LastOrdersSellProfit += OrderProfit() + OrderCommission() + OrderSwap();
     }
   }
  
  int k = OrdersHistoryTotal() - 1;
   
  while (true)
   {
    if (!OrderSelect(k, SELECT_BY_POS, MODE_HISTORY))
     break;
    
    if ((OrderOpenTime() < TimeB || totb == 0) &&
        (OrderOpenTime() < TimeS || tots == 0))
     break;
    
    if (OrderSymbol() == Symbol())
     {
      if (OrderMagicNumber() == magicbuy &&
          OrderType()        == OP_BUY   &&
          OrderOpenTime()    >  TimeB)
       ProfitBuyN += OrderProfit() + OrderSwap() + OrderCommission();
      
      if (OrderMagicNumber() == magicsell &&
          OrderType()        == OP_SELL   &&
          OrderOpenTime()    >  TimeS)
       ProfitSellN += OrderProfit() + OrderSwap() + OrderCommission();
     }
    
    k--;
   }
  
  BalanceBuy  -= ProfitBuyN;
  BalanceSell -= ProfitSellN;
  
  ProfitBuy  = NormalizeDouble(ProfitBuyN  / BalanceBuy  * 100, 1);
  ProfitSell = NormalizeDouble(ProfitSellN / BalanceSell * 100, 1);
  
  //-------------------------
  return;
 }
//===================================================================================================================================================
void Trail_LOT(double mtpb,     double mtps,
               double LO_mtpb,  double LO_mtps,
               int    cLO_mtpb, int    cLO_mtps)
 {
  
  int spread_ = (int)MathFloor(MarketInfo(Symbol(), MODE_SPREAD));
  
  if (totb >= nOrder)
   {
    if (cLO_mtpb == LOTColor)
     {
      if (Bid <= LO_mtpb && MathAbs((Bid - mtpb) / Point) > spread_)
       {
        CloseLastOrdersBuy();
        
        return;
       }
      
      if (LO_mtpb < (Bid - LO_Tral_Size * Point))
       {
        if (NotFast)
         DrawLine("BuyLOT", Bid - LO_Tral_Size * Point, LOTColor, 3);
        else
         vLO_mtpb = Bid - LO_Tral_Size * Point;
       }
     }
    
    if (cLO_mtpb != LOTColor && Bid >= LO_mtpb + LO_Tral_Start * Point)
     {
      if (NotFast)
       DrawLine("BuyLOT", Bid - LO_Tral_Start * Point, LOTColor, 3);
      else
       vcLO_mtpb = LOTColor;
     }
   }
  
  //-----------------------------------------------------------------------------------
  if (tots >= nOrder)
   {
    if (cLO_mtps == LOTColor)
     {
      if (Ask >= LO_mtps && MathAbs((Ask - mtps) / Point) > spread_)
       {
        CloseLastOrdersSell();
        
        return;
       }
      
      if (LO_mtps > (Ask + LO_Tral_Size * Point))
       {
        if (NotFast)
         DrawLine("SellLOT", Ask + LO_Tral_Size * Point, LOTColor, 3);
        else
         vLO_mtps = Ask + LO_Tral_Size * Point;
       }
     }
    
    if (cLO_mtps != LOTColor && Ask <= LO_mtps - LO_Tral_Start * Point)
     {
      if (NotFast)
       DrawLine("SellLOT", Ask + LO_Tral_Start * Point, LOTColor, 3);
      else
       vcLO_mtps = LOTColor;
     }
   }
  
  //-------------------------
  return;
 }
//===================================================================================================================================================
void Trail_VTP(int ctpb, int ctps, double mtpb, double mtps)
 {
  if (totb > 0)
   {
    if (ctpb == TralColor)
     {
      if (Bid <= mtpb)
       {
        closeBUYorders();
        
        return;
       }
      
      if (mtpb < (Bid - Tral_Size * Point))
       {
        if (NotFast)
         DrawLine("BuyTP", Bid - Tral_Size * Point, TralColor, 2);
        else
         vmtpb = Bid - Tral_Size * Point;
       }
     }
    
    if (ctpb != TralColor && Bid >= mtpb + Tral_Start * Point)
     {
      if (NotFast)
       DrawLine("BuyTP", Bid - Tral_Start * Point, TralColor, 2);
      else
       vctpb = TralColor;
     }
   }
  
  //-------------------------------------------------------------------------------------
  if (tots > 0)
   {
    if (ctps == TralColor)
     {
      if (Ask >= mtps)
       {
        closeSELLorders();
        
        return;
       }
      
      if (mtps > (Ask + Tral_Size * Point))
       {
        if (NotFast)
         DrawLine("SellTP", Ask + Tral_Size * Point, TralColor, 2);
        else
         vmtps = Ask + Tral_Size * Point;
       }
     }
    
    if (ctps != TralColor && Ask <= mtps - Tral_Start * Point)
     {
      if (NotFast)
       DrawLine("SellTP", Ask + Tral_Start * Point, TralColor, 2);
      else
       vctps = TralColor;
     }
   }
  
  //-------------------------
  return;
 }
//===================================================================================================================================================
void Trail_VTP_OFF(double mtpb, double mtps, double TPB, double TPS)
 {
  bool q = false;
  
  int spread_ = (int)MathFloor(MarketInfo(Symbol(), MODE_SPREAD));
  
  //-------------------------------------------------------------------------------------
  if (totb > 0 && MathAbs((TPB - NormalizeDouble(mtpb, Digits)) / Point) > CU &&
                  MathAbs((Bid - NormalizeDouble(mtpb, Digits)) / Point) > spread_)
   {
    for (i = 0; i < totb; i++)
     {
      if (OrderSelect(TicketB[i], SELECT_BY_TICKET))
       while (!q)
        {
         q = OrderModify(OrderTicket(), OrderOpenPrice(), 0, NormalizeDouble(mtpb, Digits), 0);
         
         Sleep(1000);
        }
       
       q = false;
     }
   }
  
  //-------------------------------------------------------------------------------------
  if (tots > 0 && MathAbs((TPS - NormalizeDouble(mtps, Digits)) / Point) > CU &&
                  MathAbs((Ask - NormalizeDouble(mtps, Digits)) / Point) > spread_)
   {
    for (i = 0; i < tots; i++)
     {
      if (OrderSelect(TicketS[i], SELECT_BY_TICKET))
       while (!q)
        {
         q = OrderModify(OrderTicket(), OrderOpenPrice(), 0, NormalizeDouble(mtps, Digits), 0);
         
         Sleep(1000);
        }
       
       q = false;
     }
   }
  
  //-------------------------
  return;
 }
//===================================================================================================================================================
void Filling_Array_Tickets()
 {
  for (r = 0; r < OrdersTotal(); r++)
   {
    if (OrderSelect(r, SELECT_BY_POS, MODE_TRADES))
     {
      if (OrderSymbol() == Symbol())
       {
        if (OrderType()        == OP_BUY   &&
           (OrderMagicNumber() == magicbuy || MagicCheck()))
         {
          TicketB[totb] = OrderTicket();
          totb++;
         }
        
        if (OrderType()        == OP_SELL   &&
           (OrderMagicNumber() == magicsell || MagicCheck()))
         {
          TicketS[tots] = OrderTicket();
          tots++;
         }
       }
     }
    else
     {
      Print("Сбой, при переборе ордеров, производится новый расчет");
      
      return;
     }
   }
  
  //-------------------------
  return;
 }
//===================================================================================================================================================
void Sorts_Array_Tickets_Buy()
 {
  double pr1 = 0.0,
         pr2 = 0.0,
         pr3 = 0.0;
  
  for (i = 0; i < totb - 1; i++)
   {
    if (OrderSelect(TicketB[i], SELECT_BY_TICKET))
     {
      pr1 = OrderOpenPrice();
      pr3 = pr1;
      r   = i;
     }
    
    for (j = i + 1; j < totb; j++)
     {
      if (OrderSelect(TicketB[j], SELECT_BY_TICKET))
       pr2 = OrderOpenPrice();
      
      if (pr2 < pr3)
       {
        pr3 = pr2;
        r   = j;
       }
     }
    
    if (r != i)
     {
      j          = TicketB[i];
      TicketB[i] = TicketB[r];
      TicketB[r] = j;
     }
   }
  
  //-------------------------
  return;
 }
//===================================================================================================================================================
void Sorts_Array_Tickets_Sell()
 {
  double pr1 = 0.0,
         pr2 = 0.0,
         pr3 = 0.0;
  
  for (i = 0; i < tots - 1; i++)
   {
    if (OrderSelect(TicketS[i], SELECT_BY_TICKET))
     {
      pr1 = OrderOpenPrice();
      pr3 = pr1;
      r   = i;
     }
    
    for (j = i + 1; j < tots; j++)
     {
      if (OrderSelect(TicketS[j], SELECT_BY_TICKET))
       pr2 = OrderOpenPrice();
      
      if (pr2 > pr3)
       {
        pr3 = pr2;
        r   = j;
       }
     }
    
    if (r != i)
     {
      j          = TicketS[i];
      TicketS[i] = TicketS[r];
      TicketS[r] = j;
     }
   }
  
  //-------------------------
  return;
 }
//===================================================================================================================================================
void CalculateTP_Buy(double TV,   double profitbuy, double BalanceBuy,
                     double ztpb, double tpb,       double LOtpb,
                     double TPbuy)
 {
  if (hb != totb || (NotFast && (ObjectFind("BuyTP")        < 0 ||
                                 ObjectFind("BuyZeroLevel") < 0 ||
                                (ObjectFind("BuyLOT")       < 0 && UseLOT && totb >= nOrder))))
   {
    if (NotFast)
     {
      ObjectDelete("BuyTP");
      ObjectDelete("BuyLOT");
      ObjectDelete("BuyZeroLevel");
      ObjectDelete("BuyTP_Back");
      ObjectDelete("BuyTP_Text");
     }
    
    hb = totb;
    
    if (totb > 0)
     {
      ztpb = NormalizeDouble(Bid, Digits) - NormalizeDouble((profitbuy / (smbuy * TV)) * Point, Digits);
      
      if (CurrencyProfit)
       {
        double PrPB = BalanceBuy * Profit / 100;
        
        tpb = ztpb + NormalizeDouble(PrPB / (smbuy * TV) * Point, Digits);
       }
      else
       tpb = ztpb + TPbuy * Point;
      
      if (UseLOT && totb >= nOrder)
       {
        LOtpb = NormalizeDouble(Bid + ((- LastOrdersBuyProfit) /
                                         (LastOrdersBuyLots * TV) + (LO_TP + TPstep_Buy * (totb - 1))) * Point, Digits);
        
        if (NotFast)
         DrawLine("BuyLOT", LOtpb, BuyColor, 3);
        else
         {
          vLO_mtpb  = LOtpb;
          vcLO_mtpb = BuyColor;
         }
       }
      
      if (NotFast)
       {
        DrawLine("BuyTP",        tpb,  BuyColor, 2);
        DrawLine("BuyZeroLevel", ztpb, BuyColor, 0);
       }
      else
       {
        vctpb = BuyColor;
        vmtpb = tpb;
       }
     }
   }
  
  //-------------------------
  return;
 }
//===================================================================================================================================================
void CalculateTP_Sell(double TV,   double profitsell, double BalanceSell,
                      double ztps, double tps,       double LOtps,
                      double TPsell)
 {
  if (hs != tots || (NotFast && (ObjectFind("SellTP")        < 0 ||
                                 ObjectFind("SellZeroLevel") < 0 ||
                                (ObjectFind("SellLOT")       < 0 && UseLOT && tots >= nOrder))))
   {
    if (NotFast)
     {
      ObjectDelete("SellTP");
      ObjectDelete("SellLOT");
      ObjectDelete("SellZeroLevel");
      ObjectDelete("SellTP_Back");
      ObjectDelete("SellTP_Text");
     }
    
    hs = tots;
    
    if (tots > 0)
     {
      ztps = NormalizeDouble(Ask, Digits) + NormalizeDouble((profitsell / (smsell * TV)) * Point, Digits);
      
      if (CurrencyProfit)
       {
        double PrPS = BalanceSell * Profit / 100;
        
        tps = ztps - NormalizeDouble(PrPS / (smsell * TV) * Point, Digits);
       }
      else
       tps = ztps - TPsell * Point;
      
      if (UseLOT && tots >= nOrder)
       {
        LOtps = NormalizeDouble(Ask - ((- LastOrdersSellProfit) /
                                         (LastOrdersSellLots * TV) + (LO_TP + TPstep_Sell * (tots - 1))) * Point, Digits);
        
        if (NotFast)
         DrawLine("SellLOT", LOtps, SellColor, 3);
        else
         {
          vLO_mtps  = LOtps;
          vcLO_mtps = SellColor;
         }
       }
      
      if (NotFast)
       {
        DrawLine("SellTP",        tps,  SellColor, 2);
        DrawLine("SellZeroLevel", ztps, SellColor, 0);
       }
      else
       {
        vctps = SellColor;
        vmtps = tps;
       }
     }
   }
  
  //-------------------------
  return;
 }
//===================================================================================================================================================
//=================================================================================================================================================//
// Kordan. Функция расчета текущего состояния по открытым ордерам                                                                                  //
//=================================================================================================================================================//
double CurrentCondition(string OrdType, string inf)
 {
  int  Pos = 0;
  
  double result       = 0,   Count         = 0,
         AveragePrice = 0,   profit        = 0;
  double LastPriceBuy = 0.0, LastPriceSell = 0.0,
         ProfitBuy    = 0.0, ProfitSell    = 0.0,
         SumProfit    = 0.0;
  
  for (int cnt_0 = 0; cnt_0 < OrdersTotal(); cnt_0++)
   {
    if (OrderSelect(cnt_0, SELECT_BY_POS, MODE_TRADES))
     if ((OrderSymbol()      == Symbol() &&
          OrderMagicNumber() == magicbuy) || magicsell || MagicCheck())
      if (OrderType() == OP_SELL ||
          OrderType() == OP_BUY)
       {
        if (inf == "Lpos")
         {
          profit = OrderProfit();
          Pos    = OrderTicket();
          
          if (profit > 0 &&
              profit > Lprofit)
           {
            Lprofit1 = Lprofit;
            Lpos1    = Lpos;
            Lprofit  = profit;                      // макс. значение
            Lpos     = Pos;
           }
          
          if (profit < 0 &&
              profit < Cprofit)
           {
            Cprofit = profit;                       //мин. значение
            Cpos    = Pos;
           }
         }
        
        SumProfit += OrderProfit() + OrderSwap() + OrderCommission();
        
        if (inf == "CurrentDrawdown")
         result = MathMax((AccountBalance() + AccountCredit() - AccountEquity()) /
                          (AccountBalance() + AccountCredit()) * 100,0 );
        
        if (inf == "CurrentUrov" && AccountMargin() > 0)
         result = AccountEquity() / AccountMargin() * 100;
        
        if (inf == "TotalOrd")
         result++;
        
        if (OrdType == "Buy")
         if (OrderType() == OP_BUY)
          {
           if (inf == "TotalBuy")
            result++;
           
           if (inf == "LastLotBuy")
            result = OrderLots();
           
           if (inf == "SumLotBuy")
            result += OrderLots();
           
           AveragePrice += OrderOpenPrice() * OrderLots();
           Count        += OrderLots();
           LastPriceBuy  = OrderOpenPrice();
           ProfitBuy    += OrderProfit() + OrderSwap() + OrderCommission();
           
           if (AveragePrice > 0 && Count > 0)
            {
             if (inf == "CalculateAveragePriceBuy")
              return(NormalizeDouble(AveragePrice / Count, Digits));
            }
           else
            return(0);
          }
        
        if (OrdType == "Sell")
         if (OrderType() == OP_SELL)
          {
           if (inf == "TotalSell")
            result++;
           
           if (inf == "LastLotSell")
            result = OrderLots();
           
           if (inf == "SumLotSell")
            result += OrderLots();
           
           AveragePrice  += OrderOpenPrice() * OrderLots();
           Count         += OrderLots();
           LastPriceSell  = OrderOpenPrice();
           ProfitSell    += OrderProfit() + OrderSwap() + OrderCommission();
           
           if (AveragePrice > 0 && Count > 0)
            {
             if (inf == "CalculateAveragePriceSell")
              return(NormalizeDouble(AveragePrice / Count, Digits));
            }
           else
            return(0);
          }
       }
   }
  
  if (inf == "Lpos")                                  // Ордер с наибольшим профитом
   return(Lpos);
  
  if (inf == "Cpos")                                  // Ордер с наименьшим профитом
   return(Cpos);
  
  if (inf == "LastPriceBuy")
   return(NormalizeDouble(LastPriceBuy, Digits));
  
  if (inf == "LastPriceSell")
   return(NormalizeDouble(LastPriceSell, Digits));
  
  if (inf == "ProfitBuy")
   return(NormalizeDouble(ProfitBuy, 2));
  
  if (inf == "ProfitSell")
   return(NormalizeDouble(ProfitSell, 2));
  
  if (inf == "SumProfit")
   return(NormalizeDouble(SumProfit, 2));
  
  //-------------------------
  return(result);
 }
//===================================================================================================================================================
//=================================================================================================================================================//
// Shvonder. Перекрытие ордеров                                                                                                                    //
//=================================================================================================================================================//
void CheckOverlapping(int totbuy, int totsell)
 {
  Lpos    = 0; Cpos    = 0;
  Lprofit = 0; Cprofit = 0;
  
  Lpos = (int)NormalizeDouble(CurrentCondition("", "Lpos"), 0);
  Cpos = (int)NormalizeDouble(CurrentCondition("", "Cpos"), 0);
  
  if (totbuy + totsell >= LeadingOrder)
   {
    if (Lprofit  >  0 &&
        Lprofit1 <= 0 && Cprofit < 0)
     {
      if (Lprofit + Cprofit > 0 &&
         (Lprofit + Cprofit) * 100 / Lprofit > ProfitPersent)
       {
        Lpos1 = 0;
        CloseSelectOrder();
       }
     }
    else
     if (Lprofit  > 0 &&
         Lprofit1 > 0 && totbuy + totsell > LeadingOrder && Cprofit < 0)
      {
       if (Lprofit + Lprofit1 + Cprofit > 0 &&
          (Lprofit + Lprofit1 + Cprofit) * 100 / (Lprofit + Lprofit1) > SecondProfitPersent)
        CloseSelectOrder();
      }
   }
  
  //-------------------------
  return;
 }
//===================================================================================================================================================
//=================================================================================================================================================//
// Shvonder. Закрытие перекретных ордеров                                                                                                          //
//=================================================================================================================================================//
int CloseSelectOrder()
 {
  if (Debug)
   Print("Функция перекрытия ордеров.");
  
  int error =  0;
  int error1 = 0;
  int error2 = 0;
  int Result = 0;
  
  //---------------------- последний --------------------------------
  while (error1 == 0)
   {
    RefreshRates();
    
    int ii = OrderSelect(Lpos, SELECT_BY_TICKET, MODE_TRADES);
    
    if (ii != 1)
     {
      Print("Ошибка! Невозможно выбрать ордер с наибольшим профитом. Выполнение перекрытия отменено.");
      
      return(0);
     }
    
    if ((OrderSymbol()      == Symbol()  &&
         OrderMagicNumber() == magicbuy) || magicsell || MagicCheck())
     {
      if (OrderType() == OP_BUY)
       {
        error1 = OrderClose(OrderTicket(), OrderLots(), NormalizeDouble(Bid, Digits), slippage, clrBlue);
        
        if (error1 == 1)
         {
          if (Debug)
           Print("Лидирующий ордер закрыт успешно.");
          
          Sleep(500);
         }
        else
         Print("Ошибка закрытия лидирующего ордера, повторяем операцию.");
       }
      
      //-----------------------------------------------------
      if (OrderType() == OP_SELL)
       {
        error1 = OrderClose(OrderTicket(), OrderLots(), NormalizeDouble(Ask, Digits), slippage, clrRed);
        
        if (error1 == 1)
         {
          if (Debug)
           Print("Лидирующий ордер закрыт успешно");
          
          Sleep(500);
         }
        else
         Print("Ошибка закрытия лидирующего ордера, повторяем операцию.");
       }
     } 
   }
  
  //---------------------- пред последний ---------------------------
  if (Lpos1 != 0)
   {
    while (error2 == 0)
     {
      RefreshRates();
      
      i = OrderSelect(Lpos1, SELECT_BY_TICKET, MODE_TRADES);
      
      if (i != 1)
       {
        Print("Ошибка! Невозможно выбрать пред ордер с наибольшим профитом. Выполнение перекрытия отменено.");
        
        return(0);
       }
      
      if ((OrderSymbol()      == Symbol()  &&
           OrderMagicNumber() == magicbuy) || magicsell || MagicCheck())
       {
        if (OrderType() == OP_BUY)
         {
          error2 = OrderClose(OrderTicket(), OrderLots(), NormalizeDouble(Bid, Digits), slippage, clrBlue);
          
          if (error2 == 1)
           {
            if (Debug)
             Print("Пред Лидирующий ордер закрыт успешно.");
            
            Sleep(500);
           }
          else
           Print("Ошибка закрытия пред лидирующего ордера, повторяем операцию.");
         }
        
        //-----------------------------------------------------
        if (OrderType() == OP_SELL)
         {
          error2 = OrderClose(OrderTicket(), OrderLots(), NormalizeDouble(Ask, Digits), slippage, clrRed);
          
          if (error2 == 1)
           {
            if (Debug)
             Print("Пред Лидирующий ордер закрыт успешно");
            
            Sleep(500);
           }
          else
           Print("Ошибка закрытия Пред лидирующего ордера, повторяем операцию.");
         }
       } 
     }
   }
  
  //----------- выбранный (обычно с наименьшим профитом) ------------
  while (error == 0)
   {
    RefreshRates();
    
    i = OrderSelect(Cpos, SELECT_BY_TICKET, MODE_TRADES);
    
    if (i != 1)
     {
      Print("Ошибка! Невозможно выбрать ордер с наименьшим профитом. Выполнение перекрытия отменено.");
      
      return(0);
     }
    
    if ((OrderSymbol()      == Symbol()  &&
         OrderMagicNumber() == magicbuy) || magicsell || MagicCheck())
     {
      if (OrderType() == OP_BUY)
       {
        error = OrderClose(OrderTicket(), OrderLots(), NormalizeDouble(Bid, Digits), slippage, clrBlue);
        
        if (error == 1)
         {
          if (Debug)
           Print("Перекрываемый ордер закрыт успешно.");
          
          Sleep(500);
         }
        else
         Print("Ошибка закрытия перекрываемого ордера, повторяем операцию.");
       }
      
      //------------------------------------------------------------
      if (OrderType() == OP_SELL)
       {
        error = OrderClose(OrderTicket(), OrderLots(), NormalizeDouble(Ask, Digits), slippage, clrRed);
        
        if (error == 1)
         {
          if (Debug)
           Print("Перекрываемый ордер закрыт успешно.");
          
          Sleep(500);
         }
        else
         Print("Ошибка закрытия перекрываемого ордера, повторяем операцию.");
       }
     }
   }
  
  Result = 1;
  
  //-------------------------
  return(Result);
 }
//===================================================================================================================================================
//=================================================================================================================================================//
// Kordan . Функция удаления объектов                                                                                                              //
//=================================================================================================================================================//
int DeleteObject()
 {
  int ObjTotal = ObjectsTotal();
  
  string ObName;
  
  for (int ii = 0; ii < ObjTotal; ii++)
   {
    ObName = ObjectName(ii);
    
    if (StringSubstr(ObName, 0, 1) == "BuyTP"           ||
        StringSubstr(ObName, 0, 1) == "SellTP"          ||
        StringSubstr(ObName, 0, 1) == "BuyLOT"          ||
        StringSubstr(ObName, 0, 1) == "SellLOT"         ||
        StringSubstr(ObName, 0, 1) == "BuyZeroLevel"    ||
        StringSubstr(ObName, 0, 1) == "SellZeroLevel"   ||
        StringSubstr(ObName, 0, 1) == "2SS_mod"         ||
        StringSubstr(ObName, 0, 1) == "2SS_v5.0c5_mod_" ||
        StringSubstr(ObName, 0, 1) == "IPrice"          ||
        StringSubstr(ObName, 0, 1) == "2ss_TPBuy"       ||
        StringSubstr(ObName, 0, 1) == "2ss_TPSell")
     {
      ObjectDelete(ObName);
      
      ii = ii - 1;
     }
   }
  
  //-------------------------
  return(0);
 }
//===================================================================================================================================================
void Indication(string name, int corner, int Xdist, int Ydist, string txt, int fontsize, string font, color col_)
 {
  if (ObjectFind(name) < 0)
   ObjectCreate(name, OBJ_LABEL, 0, 0, 0);
  
  ObjectSet    (name, OBJPROP_CORNER, corner);
  ObjectSet    (name, OBJPROP_XDISTANCE, Xdist);
  ObjectSet    (name, OBJPROP_YDISTANCE, Ydist);
  ObjectSetText(name, txt, fontsize, font, col_);
  
  //-------------------------
  return;
 }
//===================================================================================================================================================
